options
{
  IGNORE_CASE = false;
  STATIC = false;
  LOOKAHEAD = 8;
  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(AIHintLoader)
package net.sf.colossus.parser;

import java.util.*;

import net.sf.colossus.util.Log;
import net.sf.colossus.client.LegionInfo;
import net.sf.colossus.server.Creature;

/**
 * AIHintLoader load the hints to help the AI make "good" decisions.
 * @author Romain Dolbeau
 * @version $Id$
 * @see net.sf.colossus.server.Creature
 */
public class AIHintLoader
{
    Map terrainToRecruitHintList = new HashMap();

    private class recruitHintData
    {
        char terrain;
        String recruiter;
        int number;
        String recruitee;
        ConditionTreeNode ctn = null;

        recruitHintData(char terrain,
                        String recruiter,
                        int number,
                        String recruitee)
        {
            this.terrain = terrain;
            this.recruiter = recruiter;
            this.number = number;
            this.recruitee = recruitee;
        }

        char getTerrain()
        {
            return terrain;
        }

        String getRecruitee()
        {
            return recruitee;
        }

        void setConditionTreeNode(ConditionTreeNode ctn)
        {
            this.ctn = ctn;
        }

        ConditionTreeNode getConditionTreeNode()
        {
            return ctn;
        }

        public boolean equals(Object o)
        {
            if (o instanceof recruitHintData)
            {
                recruitHintData temp = (recruitHintData)o;
                return (temp.terrain == terrain &&
                        temp.recruiter.equals(recruiter) &&
                        temp.number == number &&
                        temp.recruitee.equals(recruitee));
            }
            return false;
        }

        boolean match(char terrain,
                             String recruiter,
                             int number)
        {
            return (this.terrain == terrain &&
                    this.recruiter.equals(recruiter) &&
                    this.number == number &&
                    (ctn == null ? true : ctn.isTrue()));
        }
        
        void setOracles(net.sf.colossus.server.CanReachTerrainInterface crti,
                        net.sf.colossus.server.HasCreatureInterface hci)
        {
            if (ctn != null)
            {
                ctn.setOracles(crti,hci);
            }
        }
    }

    private abstract class ConditionTreeNode
    {
        net.sf.colossus.server.CanReachTerrainInterface crti;
        net.sf.colossus.server.HasCreatureInterface hci;
        
        abstract public boolean isTrue();
        
        synchronized void setOracles(
            net.sf.colossus.server.CanReachTerrainInterface crti,
            net.sf.colossus.server.HasCreatureInterface hci)
        {
            this.crti = crti;
            this.hci = hci;

            if (this instanceof ConditionTreeNode_BinaryOp)
            {
                ((ConditionTreeNode_BinaryOp)this).ctn1.setOracles(crti,hci);
                ((ConditionTreeNode_BinaryOp)this).ctn2.setOracles(crti,hci);

            }
            if (this instanceof ConditionTreeNode_UnaryOp)
            {
                ((ConditionTreeNode_UnaryOp)this).ctn1.setOracles(crti,hci);
            }
        }
    }

    private abstract class ConditionTreeNode_Leaf extends ConditionTreeNode
    {
        public ConditionTreeNode_Leaf()
        {
            
        }
    }

    private class ConditionTreeNode_CanReach extends ConditionTreeNode_Leaf
    {
        char terrain;

        public ConditionTreeNode_CanReach(char terrain)
        {
            super();
            this.terrain = terrain;
        }
        
        public boolean isTrue()
        {
            if (crti != null)
            {
                return crti.canReach(terrain);
            }
            return false;
        }
    }
    
    private class ConditionTreeNode_HasCreature extends ConditionTreeNode_Leaf
    {
        String name;

        public ConditionTreeNode_HasCreature(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (hci != null)
            {
                return hci.hasCreature(name);
            }
            return false;
        }
    }
    
    private abstract class ConditionTreeNode_BinaryOp extends ConditionTreeNode
    {
        ConditionTreeNode ctn1;
        ConditionTreeNode ctn2;

        public ConditionTreeNode_BinaryOp(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            this.ctn1 = ctn1;
            this.ctn2 = ctn2;
        }
    }

    private class ConditionTreeNode_BinaryAnd extends ConditionTreeNode_BinaryOp
    {
        ConditionTreeNode_BinaryAnd(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            super(ctn1,ctn2);
        }
        public boolean isTrue()
        {
            return (ctn1.isTrue() && ctn2.isTrue());
        }
    }

    private class ConditionTreeNode_BinaryOr extends ConditionTreeNode_BinaryOp
    {
        ConditionTreeNode_BinaryOr(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            super(ctn1,ctn2);
        }
        
        public boolean isTrue()
        {
            return (ctn1.isTrue() || ctn2.isTrue());
        }
    }

    private abstract class ConditionTreeNode_UnaryOp extends ConditionTreeNode
    {
        ConditionTreeNode ctn1;

        public ConditionTreeNode_UnaryOp(ConditionTreeNode ctn1)
        {
            this.ctn1 = ctn1;
        }
    }

    private class ConditionTreeNode_UnaryNot extends ConditionTreeNode_UnaryOp
    {
        public ConditionTreeNode_UnaryNot(ConditionTreeNode ctn1)
        {
            super(ctn1);
        }

        public boolean isTrue()
        {
            return (!(ctn1.isTrue()));
        }
    }
    
    public String getRecruitHint(char terrain,
                                 LegionInfo legion,
                                 net.sf.colossus.server.CanReachTerrainInterface crti,
                                 net.sf.colossus.server.HasCreatureInterface hci)
    {
        Character index = new Character(terrain);

        List temp = (List)terrainToRecruitHintList.get(index);
        String hint = null;

        if (temp == null)
        { // no hint for this terrain
            return null;
        }

        Iterator hintIt = temp.iterator();
        while (hintIt.hasNext() && (hint == null))
        {
            recruitHintData th = (recruitHintData)hintIt.next();
            
            ConditionTreeNode ctn = th.getConditionTreeNode();
            
            synchronized (ctn)
            {
                ctn.setOracles(crti,hci);
                
                Iterator legionIt = legion.getContents().iterator();
                while (legionIt.hasNext() && (hint == null))
                { // this will try creatures as many times as they exist. yuck !
                    String creature = (String)legionIt.next();
                    
                    if (th.match(terrain, creature, legion.numCreature(creature)))
                    {
                        hint = th.getRecruitee();
                    }
                }
            }
        }
        return hint;
    }
}

PARSER_END(AIHintLoader)

SKIP :
{
    " "
  | "\r"
  | "\t"
}

TOKEN :
{
        < COMMENT : "#"(<NOTNEWLINE>)*"\r" | "#"(<NOTNEWLINE>)*"\n" >
|       < #NOTNEWLINE : ~["\n","\r"] >
}

String h_comment() :
{}
{
    <COMMENT>
    {
        return(new String(token.image));
    }
}

TOKEN :
{
    < EOL: "\n" >
}

TOKEN :
{
    < RECRUIT : "RECRUIT" >
|   < CANREACH : "CANREACH" >
|   < HASCREATURE : "HASCREATURE" >
|   < OR : "OR" >
|   < AND : "AND" >
|   < NOT: "NOT" >
|   < OPENPAR : "(" >
|   < CLOSEPAR : ")" >
}

TOKEN :
{
    < NUMBER : ("-")?(<DIGIT>)+ >
|   < #DIGIT : ["0" - "9"] >
}

TOKEN:
{
    < TERRAINLIST : (<TERCAR><COMMA>)*<TERCAR> >
|   < #TERCAR : ["a"-"z","A"-"Z"] >
|   < #COMMA : "," >
}

TOKEN :
{
    < CHAINE : (<CAR>)+ >
|   < QUOTEDCHAINE : "\"" (<QUOTEDCAR>)+ "\"" >
|   < #CAR : ["a"-"z","A"-"Z"] >
|   < #QUOTEDCAR : ["a"-"z","A"-"Z","0"-"9"," ","_"] >
}

char h_char() :
{}
{
    <TERRAINLIST>
    { return (token.image.charAt(0)); }
}

String h_chaine() :
{}
{
    <CHAINE>
    {
        return(new String(token.image));
    }
|   <QUOTEDCHAINE>
    {
        String tok = new String(token.image);
        String cha = tok.substring(1, tok.length() - 1);
        return(cha);
    }
}

int h_number() :
{}
{
    <NUMBER>
    {
        return(Integer.parseInt(token.image));
    }
}

char h_reachterrain() :
{
    char tc;
}
{
    <CANREACH> (tc = h_char())
        {
            return tc;
        }
}

String h_hascreature() :
{
    String name;
}
{
    <HASCREATURE> (name = h_chaine())
        {
            return name;
        }
}

ConditionTreeNode h_condnode() :
{
    ConditionTreeNode ctn1;
    ConditionTreeNode ctn2;
    char tc;
    String name;
}
{
    <OPENPAR> (ctn1 = h_condnode()) <OR> (ctn2 = h_condnode()) <CLOSEPAR>
    {
        return new ConditionTreeNode_BinaryOr(ctn1,ctn2);
    }
|   <OPENPAR> (ctn1 = h_condnode()) <AND> (ctn2 = h_condnode()) <CLOSEPAR>
    {
        return new ConditionTreeNode_BinaryAnd(ctn1,ctn2);
    }
|   <OPENPAR> <NOT> (ctn1 = h_condnode()) <CLOSEPAR>
    {
        return new ConditionTreeNode_UnaryNot(ctn1);
    }
|   <OPENPAR> (tc = h_reachterrain()) <CLOSEPAR>
    {
        return new ConditionTreeNode_CanReach(tc);
    }
|   <OPENPAR> (name = h_hascreature()) <CLOSEPAR>
    {
        return new ConditionTreeNode_HasCreature(name);
    }
}

recruitHintData h_recruit_hint() :
{
    char tc;
    String recruiter;
    int number;
    String recruitee;
}
{
    <RECRUIT> (tc = h_char()) (recruiter = h_chaine()) (number = h_number()) (recruitee = h_chaine())
        {
            return new recruitHintData(tc,recruiter,number,recruitee);
        }
}

int oneHint() :
{
    recruitHintData recruitHint;
    String s;
    ConditionTreeNode ctn = null;
}
{
    (recruitHint = h_recruit_hint()) (ctn = h_condnode())?
    {
        Character index = new Character(recruitHint.getTerrain());

        List temp = (List)terrainToRecruitHintList.get(index);

        if (temp == null)
        {
            temp = new ArrayList();
            terrainToRecruitHintList.put(index, temp);
        }
        
        if (ctn != null)
        {
            recruitHint.setConditionTreeNode(ctn);
        }

        temp.add(recruitHint);
        return(1);
    }
|   <EOL>
    {
        return(0);
    }
|   (s = h_comment())
    {
        return(0);
    }
|   <EOF>
    {
        return(-1);
    }
}
