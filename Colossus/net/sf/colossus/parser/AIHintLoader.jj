options
{
  IGNORE_CASE = false;
  STATIC = false;
  LOOKAHEAD = 20;
  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(AIHintLoader)
package net.sf.colossus.parser;

import java.util.*;

import net.sf.colossus.util.Log;
import net.sf.colossus.client.LegionInfo;
import net.sf.colossus.server.Creature;
import net.sf.colossus.server.HintOracleInterface;

/**
 * AIHintLoader load the hints to help the AI make "good" decisions.
 * @author Romain Dolbeau
 * @version $Id$
 * @see net.sf.colossus.server.Creature
 */
public class AIHintLoader
{
    Map terrainToRecruitHintList = new HashMap();

    private class recruitHintData
    {
        char terrain;
        String recruiter;
        int number;
        String recruitee;
        ConditionTreeNode ctn = null;
        HintOracleInterface oracle = null;

        recruitHintData(char terrain,
                        String recruiter,
                        int number,
                        String recruitee)
        {
            this.terrain = terrain;
            this.recruiter = recruiter;
            this.number = number;
            this.recruitee = recruitee;
        }

        char getTerrain()
        {
            return terrain;
        }

        String getRecruiter()
        {
            return recruiter;
        }

        int getNumber()
        {
            return number;
        }

        String getRecruitee()
        {
            return recruitee;
        }

        void setConditionTreeNode(ConditionTreeNode ctn)
        {
            this.ctn = ctn;
        }

        ConditionTreeNode getConditionTreeNode()
        {
            return ctn;
        }

        public boolean equals(Object o)
        {
            if (o instanceof recruitHintData)
            {
                recruitHintData temp = (recruitHintData)o;
                return (temp.terrain == terrain &&
                        temp.recruiter.equals(recruiter) &&
                        temp.number == number &&
                        temp.recruitee.equals(recruitee));
            }
            return false;
        }

        boolean match(char terrain,
                      String recruiter,
                      int number)
        {
            if (oracle == null)
            {
                Log.warn("HINT: no oracle available ! (" +
                         terrain + " / " + number + " / " + recruiter + ")");
            }
            return ((oracle == null ?
                         true :
                         oracle.creatureAvailable(recruitee) > 0) &&
                    (this.terrain == terrain) &&
                    (this.recruiter.equals(recruiter)) &&
                    (this.number == number) &&
                    (ctn == null ? true : ctn.isTrue()));
        }
        
        void setOracle(HintOracleInterface oracle)
        {
            if (ctn != null)
            {
                ctn.setOracle(oracle);
            }
            this.oracle = oracle;
        }
    }

    private abstract class ConditionTreeNode
    {
        HintOracleInterface oracle;
        
        abstract public boolean isTrue();
        
        synchronized void setOracle(HintOracleInterface oracle)
        {
            this.oracle = oracle;

            if (this instanceof ConditionTreeNode_BinaryOp)
            {
                ((ConditionTreeNode_BinaryOp)this).ctn1.setOracle(oracle);
                ((ConditionTreeNode_BinaryOp)this).ctn2.setOracle(oracle);

            }
            if (this instanceof ConditionTreeNode_UnaryOp)
            {
                ((ConditionTreeNode_UnaryOp)this).ctn1.setOracle(oracle);
            }
        }
    }

    private abstract class ConditionTreeNode_Leaf extends ConditionTreeNode
    {
        public ConditionTreeNode_Leaf()
        {
            
        }
    }

    private class ConditionTreeNode_CanReach extends ConditionTreeNode_Leaf
    {
        char terrain;

        public ConditionTreeNode_CanReach(char terrain)
        {
            super();
            this.terrain = terrain;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.canReach(terrain);
            }
            return false;
        }

        public String toString()
        {
            return "( stack can reach a " + terrain + ")";
        }
    }
    
    private class ConditionTreeNode_HasCreature extends ConditionTreeNode_Leaf
    {
        String name;

        public ConditionTreeNode_HasCreature(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.hasCreature(name);
            }
            return false;
        }

        public String toString()
        {
            return "( stack has " + name + ")";
        }
    }

    private class ConditionTreeNode_CreatureAvailable extends ConditionTreeNode_Leaf
    {
        int n;
        String name;

        public ConditionTreeNode_CreatureAvailable(int n, String name)
        {
            super();
            this.n = n;
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return (oracle.creatureAvailable(name) >= n);
            }
            return false;
        }

        public String toString()
        {
            return "( at least " + n + " " + name + " are available )";
        }
    }

    private class ConditionTreeNode_HeightIs extends ConditionTreeNode_Leaf
    {
        int h;

        public ConditionTreeNode_HeightIs(int h)
        {
            super();
            this.h = h;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return (oracle.stackHeight() == h);
            }
            return false;
        }

        public String toString()
        {
            return "( stack height is " + h + " )";
        }
    }

    private class ConditionTreeNode_CanRecruit extends ConditionTreeNode_Leaf
    {
        String name;
        
        public ConditionTreeNode_CanRecruit(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.canRecruit(name);
            }
            return false;
        }

        public String toString()
        {
            return "( stack can recruit " + name + " )";
        }
    }

    private class ConditionTreeNode_LabelIs extends ConditionTreeNode_Leaf
    {
        String name;
        
        public ConditionTreeNode_LabelIs(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.hexLabel().equals(name);
            }
            return false;
        }

        public String toString()
        {
            return "( stack is in hex " + name + " )";
        }
    }

    private class ConditionTreeNode_Random extends ConditionTreeNode_Leaf
    {
        double p;
        Random rnd = new Random();

        public ConditionTreeNode_Random(double p)
        {
            if (p > 1.0)
                this.p = 1.0;
            else
                if (p < 0.0)
                    this.p = 0.0;
                else
                    this.p = p;
        }

        public boolean isTrue()
        {
            return (rnd.nextDouble() < p);
        }

        public String toString()
        {
            return "( " + (100 * p) + " % )";
        }
    }
    
    private abstract class ConditionTreeNode_BinaryOp extends ConditionTreeNode
    {
        ConditionTreeNode ctn1;
        ConditionTreeNode ctn2;

        public ConditionTreeNode_BinaryOp(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            this.ctn1 = ctn1;
            this.ctn2 = ctn2;
        }
    }

    private class ConditionTreeNode_BinaryAnd extends ConditionTreeNode_BinaryOp
    {
        ConditionTreeNode_BinaryAnd(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            super(ctn1,ctn2);
        }

        public boolean isTrue()
        {
            return (ctn1.isTrue() && ctn2.isTrue());
        }

        public String toString()
        {
            return "( " + ctn1 + " and " + ctn2 + " )";
        }
    }

    private class ConditionTreeNode_BinaryOr extends ConditionTreeNode_BinaryOp
    {
        ConditionTreeNode_BinaryOr(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            super(ctn1,ctn2);
        }
        
        public boolean isTrue()
        {
            return (ctn1.isTrue() || ctn2.isTrue());
        }

        public String toString()
        {
            return "( " + ctn1 + " or " + ctn2 + " )";
        }
    }

    private abstract class ConditionTreeNode_UnaryOp extends ConditionTreeNode
    {
        ConditionTreeNode ctn1;

        public ConditionTreeNode_UnaryOp(ConditionTreeNode ctn1)
        {
            this.ctn1 = ctn1;
        }
    }

    private class ConditionTreeNode_UnaryNot extends ConditionTreeNode_UnaryOp
    {
        public ConditionTreeNode_UnaryNot(ConditionTreeNode ctn1)
        {
            super(ctn1);
        }

        public boolean isTrue()
        {
            return (!(ctn1.isTrue()));
        }

        public String toString()
        {
            return "( not " + ctn1 + " )";
        }
    }
    
    public synchronized String getRecruitHint(
        char terrain,
        LegionInfo legion,
        HintOracleInterface oracle)
    {
        Character index = new Character(terrain);
        
        List temp = (List)terrainToRecruitHintList.get(index);
        String hint = null;
        
        if (temp == null)
        { // no hint for this terrain
            return null;
        }
        
        Iterator hintIt = temp.iterator();
        while (hintIt.hasNext() && (hint == null))
        {
            recruitHintData th = (recruitHintData)hintIt.next();

            synchronized (th)
            {
                th.setOracle(oracle);
                    
                Iterator legionIt = legion.getContents().iterator();
                while (legionIt.hasNext() && (hint == null))
                { // this will try creatures as many times as they exist. yuck !
                    String creature = (String)legionIt.next();
                    
                    if (th.match(terrain, creature, legion.numCreature(creature)))
                    {
                        hint = th.getRecruitee();
                    }
                }
                // remove the Oracle, just in case
                th.setOracle(null);
            }
        }
        return hint;
    }
}

PARSER_END(AIHintLoader)

SKIP :
{
    " "
  | "\r"
  | "\t"
  | "\n"
}

TOKEN :
{
        < COMMENT : "#"(<NOTNEWLINE>)*"\r" | "#"(<NOTNEWLINE>)*"\n" >
|       < #NOTNEWLINE : ~["\n","\r"] >
}

String h_comment() :
{}
{
    <COMMENT>
    {
        return(new String(token.image));
    }
}

TOKEN :
{
    < RECRUIT : "RECRUIT" >
|   < CANREACH : "CANREACH" >
|   < HASCREATURE : "HASCREATURE" >
|   < HEIGHTIS : "HEIGHTIS" >
|   < CANRECRUIT : "CANRECRUIT" >
|   < LABELIS : "LABELIS" >
|   < AVAILABLE : "AVAILABLE" >
|   < RANDOM : "RANDOM" >
|   < OR : "OR" >
|   < AND : "AND" >
|   < NOT: "NOT" >
|   < OPENPAR : "(" >
|   < CLOSEPAR : ")" >
}

TOKEN :
{
    < NUMBER : ("-")?(<DIGIT>)+ >
|   < FPNUMBER : (<DIGIT>)+<DOT>(<DIGIT>)* >
|   < #DIGIT : ["0" - "9"] >
|   < #DOT : "." >
}

TOKEN:
{
    < TERRAINLIST : (<TERCAR><COMMA>)*<TERCAR> >
|   < #TERCAR : ["a"-"z","A"-"Z"] >
|   < #COMMA : "," >
}

TOKEN :
{
    < CHAINE : (<CAR>)+ >
|   < QUOTEDCHAINE : "\"" (<QUOTEDCAR>)+ "\"" >
|   < #CAR : ["a"-"z","A"-"Z"] >
|   < #QUOTEDCAR : ["a"-"z","A"-"Z","0"-"9"," ","_"] >
}

char h_char() :
{}
{
    <TERRAINLIST>
    { return (token.image.charAt(0)); }
}

String h_chaine() :
{}
{
    <CHAINE>
    {
        return(new String(token.image));
    }
|   <QUOTEDCHAINE>
    {
        String tok = new String(token.image);
        String cha = tok.substring(1, tok.length() - 1);
        return(cha);
    }
}

int h_number() :
{}
{
    <NUMBER>
    {
        return(Integer.parseInt(token.image));
    }
}

char h_reachterrain() :
{
    char tc;
}
{
    <CANREACH> (tc = h_char())
        {
            return tc;
        }
}

double h_fpnumber() :
{}
{
    <FPNUMBER>
    { return(Double.parseDouble(token.image)); }
}


double h_random() :
{
    double p;
}
{
    <RANDOM> (p = h_fpnumber())
    {
        return p;
    }
}

ConditionTreeNode h_condnode() :
{
    ConditionTreeNode ctn1;
    ConditionTreeNode ctn2;
    char tc;
    int n;
    String name;
    double p;
}
{
    <OPENPAR> (ctn1 = h_condnode()) <OR> (ctn2 = h_condnode()) <CLOSEPAR>
    {
        return new ConditionTreeNode_BinaryOr(ctn1,ctn2);
    }
|   <OPENPAR> (ctn1 = h_condnode()) <AND> (ctn2 = h_condnode()) <CLOSEPAR>
    {
        return new ConditionTreeNode_BinaryAnd(ctn1,ctn2);
    }
|   <OPENPAR> <NOT> (ctn1 = h_condnode()) <CLOSEPAR>
    {
        return new ConditionTreeNode_UnaryNot(ctn1);
    }
|   <OPENPAR> (tc = h_reachterrain()) <CLOSEPAR>
    {
        return new ConditionTreeNode_CanReach(tc);
    }
|   <OPENPAR> <HASCREATURE> (name = h_chaine()) <CLOSEPAR>
    {
        return new ConditionTreeNode_HasCreature(name);
    }
|   <OPENPAR> (p = h_random()) <CLOSEPAR>
    {
        return new ConditionTreeNode_Random(p);
    }
|   <OPENPAR> (n = h_number()) (name = h_chaine()) <AVAILABLE> <CLOSEPAR>
    {
        return new ConditionTreeNode_CreatureAvailable(n,name);
    }
|   <OPENPAR> <CANRECRUIT> (name = h_chaine()) <CLOSEPAR>
    {
        return new ConditionTreeNode_CanRecruit(name);
    }
|   <OPENPAR> <HEIGHTIS> (n = h_number()) <CLOSEPAR>
    {
        return new ConditionTreeNode_HeightIs(n);
    }
|   <OPENPAR> <LABELIS> (name = h_chaine()) <CLOSEPAR>
    {
        return new ConditionTreeNode_LabelIs(name);
    }
}

recruitHintData h_recruit_hint() :
{
    char tc;
    String recruiter;
    int number;
    String recruitee;
}
{
    <RECRUIT> (tc = h_char()) (recruiter = h_chaine()) (number = h_number()) (recruitee = h_chaine())
        {
            return new recruitHintData(tc,recruiter,number,recruitee);
        }
}

int oneHint() :
{
    recruitHintData recruitHint;
    String s;
    ConditionTreeNode ctn = null;
}
{
    (recruitHint = h_recruit_hint()) (ctn = h_condnode())?
    {
        Character index = new Character(recruitHint.getTerrain());

        List temp = (List)terrainToRecruitHintList.get(index);

        if (temp == null)
        {
            temp = new ArrayList();
            terrainToRecruitHintList.put(index, temp);
        }
        
        if (ctn != null)
        {
            recruitHint.setConditionTreeNode(ctn);
        }

        temp.add(recruitHint);

        Log.debug("HINT: Recruit hint in " + recruitHint.getTerrain() +
                  " with " + recruitHint.getNumber() + " " + 
                  recruitHint.getRecruiter() + " get a " + 
                  recruitHint.getRecruitee() +
                  (ctn == null ? "" : " if " + ctn));
        return(1);
    }
|   (s = h_comment())
    {
        return(0);
    }
|   <EOF>
    {
        return(-1);
    }
}
