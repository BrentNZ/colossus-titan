options
{
  IGNORE_CASE = false;
  STATIC = false;
}

PARSER_BEGIN(AIHintLoader)
package net.sf.colossus.parser;

import java.util.*;

import net.sf.colossus.util.Log;
import net.sf.colossus.client.LegionInfo;
import net.sf.colossus.server.Creature;
import net.sf.colossus.server.HintOracleInterface;

/**
 * AIHintLoader load the hints to help the AI make "good" decisions.
 * @author Romain Dolbeau
 * @version $Id$
 * @see net.sf.colossus.server.Creature
 */
public class AIHintLoader
{
    Map terrainToRecruitHintList = new HashMap();
    Map labelToInitialSplitList = new HashMap();
    java.util.Stack argStack = new java.util.Stack();
    Random rnd = new Random();

    private class initialSplitHintData
    {
        List legions = new ArrayList();
        double p = 0.0;

        public initialSplitHintData()
        {
        }

        void addLegion(List legion)
        {
            legions.add(legion);
        }

        void setProbability(double p)
        {
            this.p = p;
        }

        double getProbability()
        {
            return p;
        }

        List getLegions()
        {
            return Collections.unmodifiableList(legions);
        }

        public String toString()
        {
            return "Suggested Split (" + (100 * p) + " %) : " + legions;
        }
    }

    private class recruitHintData
    {
        char terrain;
        String recruiter;
        int number;
        String recruitee;
        ConditionTreeNode ctn = null;
        HintOracleInterface oracle = null;

        recruitHintData(char terrain,
                        String recruiter,
                        int number,
                        String recruitee)
        {
            this.terrain = terrain;
            this.recruiter = recruiter;
            this.number = number;
            this.recruitee = recruitee;
        }

        char getTerrain()
        {
            return terrain;
        }

        String getRecruiter()
        {
            return recruiter;
        }

        int getNumber()
        {
            return number;
        }

        String getRecruitee()
        {
            return recruitee;
        }

        void setConditionTreeNode(ConditionTreeNode ctn)
        {
            this.ctn = ctn;
        }

        ConditionTreeNode getConditionTreeNode()
        {
            return ctn;
        }

        public boolean equals(Object o)
        {
            if (o instanceof recruitHintData)
            {
                recruitHintData temp = (recruitHintData)o;
                return (temp.terrain == terrain &&
                        temp.recruiter.equals(recruiter) &&
                        temp.number == number &&
                        temp.recruitee.equals(recruitee));
            }
            return false;
        }

        boolean match(char terrain,
                      String recruiter,
                      int number)
        {
            if (oracle == null)
            {
                Log.warn("HINT: no oracle available ! (" +
                         terrain + " / " + number + " / " + recruiter + ")");
            }
            return ((oracle == null ?
                         true :
                         oracle.creatureAvailable(recruitee) > 0) &&
                    (this.terrain == terrain) &&
                    (this.recruiter.equals(recruiter)) &&
                    (this.number == number) &&
                    (ctn == null ? true : ctn.isTrue()));
        }
        
        void setOracle(HintOracleInterface oracle)
        {
            if (ctn != null)
            {
                ctn.setOracle(oracle);
            }
            this.oracle = oracle;
        }
    }

    private abstract class ConditionTreeNode
    {
        HintOracleInterface oracle;
        
        abstract public boolean isTrue();
        
        synchronized void setOracle(HintOracleInterface oracle)
        {
            this.oracle = oracle;

            if (this instanceof ConditionTreeNode_BinaryOp)
            {
                ((ConditionTreeNode_BinaryOp)this).ctn1.setOracle(oracle);
                ((ConditionTreeNode_BinaryOp)this).ctn2.setOracle(oracle);

            }
            if (this instanceof ConditionTreeNode_UnaryOp)
            {
                ((ConditionTreeNode_UnaryOp)this).ctn1.setOracle(oracle);
            }
        }
    }

    private abstract class ConditionTreeNode_Leaf extends ConditionTreeNode
    {
        public ConditionTreeNode_Leaf()
        {
            
        }
    }

    private class ConditionTreeNode_CanReach extends ConditionTreeNode_Leaf
    {
        char terrain;

        public ConditionTreeNode_CanReach(char terrain)
        {
            super();
            this.terrain = terrain;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.canReach(terrain);
            }
            return false;
        }

        public String toString()
        {
            return "( stack can reach a " + terrain + ")";
        }
    }
    
    private class ConditionTreeNode_HasCreature extends ConditionTreeNode_Leaf
    {
        String name;

        public ConditionTreeNode_HasCreature(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.hasCreature(name);
            }
            return false;
        }

        public String toString()
        {
            return "( stack has " + name + ")";
        }
    }

    private class ConditionTreeNode_CreatureAvailable extends ConditionTreeNode_Leaf
    {
        int n;
        String name;

        public ConditionTreeNode_CreatureAvailable(int n, String name)
        {
            super();
            this.n = n;
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return (oracle.creatureAvailable(name) >= n);
            }
            return false;
        }

        public String toString()
        {
            return "( at least " + n + " " + name + " are available )";
        }
    }

    private class ConditionTreeNode_HeightIs extends ConditionTreeNode_Leaf
    {
        int h;

        public ConditionTreeNode_HeightIs(int h)
        {
            super();
            this.h = h;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return (oracle.stackHeight() == h);
            }
            return false;
        }

        public String toString()
        {
            return "( stack height is " + h + " )";
        }
    }

    private class ConditionTreeNode_CanRecruit extends ConditionTreeNode_Leaf
    {
        String name;
        
        public ConditionTreeNode_CanRecruit(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.canRecruit(name);
            }
            return false;
        }

        public String toString()
        {
            return "( stack can recruit " + name + " )";
        }
    }

    private class ConditionTreeNode_LabelIs extends ConditionTreeNode_Leaf
    {
        String name;
        
        public ConditionTreeNode_LabelIs(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.hexLabel().equals(name);
            }
            return false;
        }

        public String toString()
        {
            return "( stack is in hex " + name + " )";
        }
    }

    private class ConditionTreeNode_Random extends ConditionTreeNode_Leaf
    {
        double p;

        public ConditionTreeNode_Random(double p)
        {
            if (p > 1.0)
                this.p = 1.0;
            else
                if (p < 0.0)
                    this.p = 0.0;
                else
                    this.p = p;
        }

        public boolean isTrue()
        {
            return (rnd.nextDouble() < p);
        }

        public String toString()
        {
            return "( " + (100 * p) + " % )";
        }
    }
    
    private abstract class ConditionTreeNode_BinaryOp extends ConditionTreeNode
    {
        ConditionTreeNode ctn1;
        ConditionTreeNode ctn2;

        public ConditionTreeNode_BinaryOp(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            this.ctn1 = ctn1;
            this.ctn2 = ctn2;
        }
    }

    private class ConditionTreeNode_BinaryAnd extends ConditionTreeNode_BinaryOp
    {
        ConditionTreeNode_BinaryAnd(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            super(ctn1,ctn2);
        }

        public boolean isTrue()
        {
            return (ctn1.isTrue() && ctn2.isTrue());
        }

        public String toString()
        {
            return "( " + ctn1 + " and " + ctn2 + " )";
        }
    }

    private class ConditionTreeNode_BinaryOr extends ConditionTreeNode_BinaryOp
    {
        ConditionTreeNode_BinaryOr(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            super(ctn1,ctn2);
        }
        
        public boolean isTrue()
        {
            return (ctn1.isTrue() || ctn2.isTrue());
        }

        public String toString()
        {
            return "( " + ctn1 + " or " + ctn2 + " )";
        }
    }

    private abstract class ConditionTreeNode_UnaryOp extends ConditionTreeNode
    {
        ConditionTreeNode ctn1;

        public ConditionTreeNode_UnaryOp(ConditionTreeNode ctn1)
        {
            this.ctn1 = ctn1;
        }
    }

    private class ConditionTreeNode_UnaryNot extends ConditionTreeNode_UnaryOp
    {
        public ConditionTreeNode_UnaryNot(ConditionTreeNode ctn1)
        {
            super(ctn1);
        }

        public boolean isTrue()
        {
            return (!(ctn1.isTrue()));
        }

        public String toString()
        {
            return "( not " + ctn1 + " )";
        }
    }
    
    public synchronized String getRecruitHint(
        char terrain,
        LegionInfo legion,
        List recruits,
        HintOracleInterface oracle)
    {
        Character index = new Character(terrain);
        
        List temp = (List)terrainToRecruitHintList.get(index);
        String hint = null;
        
        if (temp == null)
        { // no hint for this terrain
            return null;
        }
        
        Iterator hintIt = temp.iterator();
        while (hintIt.hasNext() && (hint == null))
        {
            recruitHintData th = (recruitHintData)hintIt.next();

            synchronized (th)
            {
                th.setOracle(oracle);
                    
                // first, try with all the creatures in the Legion
                Iterator legionIt = legion.getContents().iterator();
                while (legionIt.hasNext() && (hint == null))
                { // this will try creatures as many times as they exist. yuck !
                    String creature = (String)legionIt.next();
                    
                    if (th.match(terrain, creature, legion.numCreature(creature)))
                    {
                        hint = th.getRecruitee();
                    }
                }
                // second, try with all recruitable creature (so that
                // hint with (number == ) are tried)
                Iterator recruitsIt = recruits.iterator();
                while (recruitsIt.hasNext() && (hint == null))
                { // this will try creatures as many times as they exist. yuck !
                    String creature = ((Creature)recruitsIt.next()).getName();
                    
                    if (th.match(terrain, creature, legion.numCreature(creature)))
                    {
                        hint = th.getRecruitee();
                    }
                }

                // remove the Oracle, just in case
                th.setOracle(null);
            }
        }
        return hint;
    }

    public synchronized List getInitialSplitHint(String label)
    {
        List allHints = (List)labelToInitialSplitList.get(label);
        List legion = null;

        if (allHints == null)
        {
            return null;
        }

        Iterator it = allHints.iterator();
        boolean done = false;

        while (it.hasNext() && !done)
        {
            initialSplitHintData ishd = (initialSplitHintData)it.next();

            if (rnd.nextDouble() < ishd.getProbability())
            {
                List legions = ishd.getLegions();

                legion = (List)legions.get(rnd.nextInt(legions.size()));

                done = true;
            }
        }

        return legion;
    }
}

PARSER_END(AIHintLoader)

SKIP :
{
    " "
  | "\r"
  | "\t"
  | "\n"
}

TOKEN :
{
        < COMMENT : "#"(<NOTNEWLINE>)*"\r" | "#"(<NOTNEWLINE>)*"\n" >
|       < #NOTNEWLINE : ~["\n","\r"] >
}

String h_comment() :
{}
{
    <COMMENT>
    {
        return(new String(token.image));
    }
}

TOKEN :
{
    < RECRUIT : "RECRUIT" >
|   < CANREACH : "CANREACH" >
|   < HASCREATURE : "HASCREATURE" >
|   < HEIGHTIS : "HEIGHTIS" >
|   < CANRECRUIT : "CANRECRUIT" >
|   < LABELIS : "LABELIS" >
|   < AVAILABLE : "AVAILABLE" >
|   < RANDOM : "RANDOM" >
|   < OR : "OR" >
|   < AND : "AND" >
|   < NOT: "NOT" >
|   < OPENPAR : "(" >
|   < CLOSEPAR : ")" >
|   < INITIALSPLIT: "INITIALSPLIT" >
}

TOKEN :
{
    < NUMBER : ("-")?(<DIGIT>)+ >
|   < FPNUMBER : (<DIGIT>)+<DOT>(<DIGIT>)* >
|   < #DIGIT : ["0" - "9"] >
|   < #DOT : "." >
}

TOKEN:
{
    < TERRAINLIST : (<TERCAR><COMMA>)*<TERCAR> >
|   < #TERCAR : ["a"-"z","A"-"Z"] >
|   < #COMMA : "," >
}

TOKEN :
{
    < CHAINE : (<CAR>)+ >
|   < QUOTEDCHAINE : "\"" (<QUOTEDCAR>)+ "\"" >
|   < #CAR : ["a"-"z","A"-"Z"] > 
|   < #QUOTEDCAR : ["a"-"z","A"-"Z","0"-"9"," ","_"] >
}

char h_char() :
{}
{
    <TERRAINLIST>
    { return (token.image.charAt(0)); }
}

String h_chaine() :
{}
{
    <CHAINE>
    {
        return(new String(token.image));
    }
|   <QUOTEDCHAINE>
    {
        String tok = new String(token.image);
        String cha = tok.substring(1, tok.length() - 1);
        return(cha);
    }
}

int h_number() :
{}
{
    <NUMBER>
    {
        return(Integer.parseInt(token.image));
    }
}

double h_fpnumber() :
{}
{
    <FPNUMBER>
    { return(Double.parseDouble(token.image)); }
}

/* initial split */

initialSplitHintData h_initialsplit_hint() :
{
    String name;
    double p;
    List inter = new ArrayList();
    initialSplitHintData ishd = new initialSplitHintData();
}
{
    (p = h_fpnumber()) ( <OPENPAR> ( (name = h_chaine())
{ inter.add(name); } )+ <CLOSEPAR> { ishd.addLegion(inter); inter = new ArrayList(); } )+
        {
            ishd.setProbability(p);
            return ishd;
        }
}


/* recruiting */

char h_recruit_reachterrain() :
{
    char tc;
}
{
    <CANREACH> (tc = h_char())
        {
            return tc;
        }
}

double h_recruit_random() :
{
    double p;
}
{
    <RANDOM> (p = h_fpnumber())
    {
        return p;
    }
}

void h_recruit_ornode() :
{}
{
    h_recruit_andnode() ( <OR> h_recruit_andnode()
    {
        ConditionTreeNode ctn1 = (ConditionTreeNode)argStack.pop();
        ConditionTreeNode ctn2 = (ConditionTreeNode)argStack.pop();
        argStack.push(new ConditionTreeNode_BinaryOr(ctn1,ctn2));
    } ) *
}

void h_recruit_andnode() :
{}
{
    h_recruit_unarynode() ( <AND> h_recruit_unarynode()
    {
        ConditionTreeNode ctn1 = (ConditionTreeNode)argStack.pop();
        ConditionTreeNode ctn2 = (ConditionTreeNode)argStack.pop();
        argStack.push(new ConditionTreeNode_BinaryAnd(ctn1,ctn2));
    } ) *
}

void h_recruit_unarynode() :
{}
{
    <NOT> h_recruit_leaf()
    {
        ConditionTreeNode ctn1 = (ConditionTreeNode)argStack.pop();
        argStack.push(new ConditionTreeNode_UnaryNot(ctn1));
    }
|   h_recruit_leaf()
}

void h_recruit_leaf() :
{
    char tc;
    int n;
    String name;
    double p;
}
{
    (tc = h_recruit_reachterrain())
    {
        argStack.push(new ConditionTreeNode_CanReach(tc));
    }
|   <HASCREATURE> (name = h_chaine())
    {
        argStack.push(new ConditionTreeNode_HasCreature(name));
    }
|   (p = h_recruit_random())
    {
        argStack.push(new ConditionTreeNode_Random(p));
    }
|   (n = h_number()) (name = h_chaine()) <AVAILABLE>
    {
        argStack.push(new ConditionTreeNode_CreatureAvailable(n,name));
    }
|   <CANRECRUIT> (name = h_chaine())
    {
        argStack.push(new ConditionTreeNode_CanRecruit(name));
    }
|   <HEIGHTIS> (n = h_number())
    {
        argStack.push(new ConditionTreeNode_HeightIs(n));
    }
|   <LABELIS> (name = h_chaine())
    {
        argStack.push(new ConditionTreeNode_LabelIs(name));
    }
|   "(" h_recruit_ornode() ")"
}

recruitHintData h_recruit_hint() :
{
    char tc;
    String recruiter;
    int number;
    String recruitee;
}
{
    <RECRUIT> (tc = h_char()) (recruiter = h_chaine()) (number = h_number()) (recruitee = h_chaine())
        {
            return new recruitHintData(tc,recruiter,number,recruitee);
        }
}

int oneHint() :
{
    recruitHintData recruitHint;
    String s;
    String label;
    initialSplitHintData ishd;
}
{
    (recruitHint = h_recruit_hint()) (h_recruit_ornode())?
    {
        Character index = new Character(recruitHint.getTerrain());

        ConditionTreeNode ctn = null;

        if (!argStack.empty())
        {
            ctn = (ConditionTreeNode)argStack.pop();
        }

        List temp = (List)terrainToRecruitHintList.get(index);

        if (temp == null)
        {
            temp = new ArrayList();
            terrainToRecruitHintList.put(index, temp);
        }
        
        if (ctn != null)
        {
            recruitHint.setConditionTreeNode(ctn);
        }

        temp.add(recruitHint);

        Log.debug("HINT: Recruit hint in " + recruitHint.getTerrain() +
                  " with " + recruitHint.getNumber() + " " + 
                  recruitHint.getRecruiter() + " get a " + 
                  recruitHint.getRecruitee() +
                  (ctn == null ? "" : " if " + ctn));
        return(1);
    }
|   <INITIALSPLIT> (label = h_chaine()) (ishd = h_initialsplit_hint())
    {
        List isl = (List)labelToInitialSplitList.get(label);

        if (isl == null)
        {
            isl = new ArrayList();
            labelToInitialSplitList.put(label, isl);
        }
        Log.debug("HINT: Initial Split hint for hex " + label + " is " + ishd);
        
        isl.add(ishd);
        
        return(1);
    }
|   (s = h_comment())
    {
        return(0);
    }
|   <EOF>
    {
        return(-1);
    }
}
