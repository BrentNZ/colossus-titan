options
{
  IGNORE_CASE = false;
  STATIC = false;
}

PARSER_BEGIN(AIHintLoader)
package net.sf.colossus.parser;

import java.util.*;

import net.sf.colossus.util.Log;
import net.sf.colossus.client.LegionInfo;
import net.sf.colossus.server.Creature;
import net.sf.colossus.server.HintOracleInterface;

/**
 * AIHintLoader load the hints to help the AI make "good" decisions.
 * @author Romain Dolbeau
 * @version $Id$
 * @see net.sf.colossus.server.Creature
 */
public class AIHintLoader implements net.sf.colossus.server.HintInterface
{
    public static final String sectionAllAI = "AllAI:";
    public static final String sectionOffensiveAI = "OffensiveAI:";
    public static final String sectionDefensiveAI = "DefensiveAI:";
    
    String currentSection = sectionAllAI;

    Map terrainToRecruitHintList = new HashMap();
    Map labelToInitialSplitList = new HashMap();
    Map nameToRecruitmentValueOffset = new HashMap();
    java.util.Stack argStack = new java.util.Stack();
    Random rnd = new Random();

    /* make sure the default entry is present, to avoid null pointer exception */
    {
        terrainToRecruitHintList.put(sectionAllAI, new HashMap());
        labelToInitialSplitList.put(sectionAllAI, new HashMap());
        nameToRecruitmentValueOffset.put(sectionAllAI, new HashMap());
    }

    private class initialSplitHintData
    {
        List legions = new ArrayList();
        double p = 0.0;

        public initialSplitHintData()
        {
        }

        void addLegion(List legion)
        {
            legions.add(legion);
        }

        void setProbability(double p)
        {
            this.p = p;
        }

        double getProbability()
        {
            return p;
        }

        List getLegions()
        {
            return Collections.unmodifiableList(legions);
        }

        public String toString()
        {
            return "Suggested Split (" + (100 * p) + " %) : " + legions;
        }
    }

    private class recruitHintData
    {
        char terrain;
        String recruiter;
        int number;
        String recruitee;
        ConditionTreeNode ctn = null;
        HintOracleInterface oracle = null;

        recruitHintData(char terrain,
                        String recruiter,
                        int number,
                        String recruitee)
        {
            this.terrain = terrain;
            this.recruiter = recruiter;
            this.number = number;
            this.recruitee = recruitee;
        }

        char getTerrain()
        {
            return terrain;
        }

        String getRecruiter()
        {
            return recruiter;
        }

        int getNumber()
        {
            return number;
        }

        String getRecruitee()
        {
            return recruitee;
        }

        void setConditionTreeNode(ConditionTreeNode ctn)
        {
            this.ctn = ctn;
        }

        ConditionTreeNode getConditionTreeNode()
        {
            return ctn;
        }

        public boolean equals(Object o)
        {
            if (o instanceof recruitHintData)
            {
                recruitHintData temp = (recruitHintData)o;
                return (temp.terrain == terrain &&
                        temp.recruiter.equals(recruiter) &&
                        temp.number == number &&
                        temp.recruitee.equals(recruitee));
            }
            return false;
        }

        public String toString()
        {
            return "RecruitHint: in " + terrain + ", " + number + " " +
                recruiter + " get a " + recruitee +
                (ctn == null ? "" : " if " + ctn);
        }

        boolean match(char terrain,
                      String recruiter,
                      int number)
        {
            if (oracle == null)
            {
                Log.warn("HINT: no oracle available ! (" +
                         terrain + " / " + number + " / " + recruiter + ")");
            }
            return ((oracle == null ?
                         true :
                         oracle.creatureAvailable(recruitee) > 0) &&
                    (this.terrain == terrain) &&
                    (this.recruiter.equals(recruiter)) &&
                    (this.number == number) &&
                    (ctn == null ? true : ctn.isTrue()));
        }
        
        void setOracle(HintOracleInterface oracle)
        {
            if (ctn != null)
            {
                ctn.setOracle(oracle);
            }
            this.oracle = oracle;
        }
    }

    private abstract class ConditionTreeNode
    {
        HintOracleInterface oracle;
        
        abstract public boolean isTrue();
        
        synchronized void setOracle(HintOracleInterface oracle)
        {
            this.oracle = oracle;

            if (this instanceof ConditionTreeNode_BinaryOp)
            {
                ((ConditionTreeNode_BinaryOp)this).ctn1.setOracle(oracle);
                ((ConditionTreeNode_BinaryOp)this).ctn2.setOracle(oracle);

            }
            if (this instanceof ConditionTreeNode_UnaryOp)
            {
                ((ConditionTreeNode_UnaryOp)this).ctn1.setOracle(oracle);
            }
        }
    }

    private abstract class ConditionTreeNode_Leaf extends ConditionTreeNode
    {
        public ConditionTreeNode_Leaf()
        {
            
        }
    }

    private class ConditionTreeNode_CanReach extends ConditionTreeNode_Leaf
    {
        char terrain;

        public ConditionTreeNode_CanReach(char terrain)
        {
            super();
            this.terrain = terrain;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.canReach(terrain);
            }
            return false;
        }

        public String toString()
        {
            return "( stack can reach a " + terrain + ")";
        }
    }
    
    private class ConditionTreeNode_HasCreature extends ConditionTreeNode_Leaf
    {
        String name;

        public ConditionTreeNode_HasCreature(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.hasCreature(name);
            }
            return false;
        }

        public String toString()
        {
            return "( stack has " + name + ")";
        }
    }

    private class ConditionTreeNode_OtherFriendlyStackHasCreature extends ConditionTreeNode_Leaf
    {
        java.util.List allNames;

        public ConditionTreeNode_OtherFriendlyStackHasCreature(java.util.List allNames)
        {
            super();
            this.allNames = allNames;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.otherFriendlyStackHasCreature(allNames);
            }
            return false;
        }

        public String toString()
        {
            return "( anotherfriendly stack has " + allNames + ")";
        }
    }

    private class ConditionTreeNode_CreatureAvailable extends ConditionTreeNode_Leaf
    {
        int n;
        String name;

        public ConditionTreeNode_CreatureAvailable(int n, String name)
        {
            super();
            this.n = n;
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return (oracle.creatureAvailable(name) >= n);
            }
            return false;
        }

        public String toString()
        {
            return "( at least " + n + " " + name + " are available )";
        }
    }

    private class ConditionTreeNode_HeightIs extends ConditionTreeNode_Leaf
    {
        int h;

        public ConditionTreeNode_HeightIs(int h)
        {
            super();
            this.h = h;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return (oracle.stackHeight() == h);
            }
            return false;
        }

        public String toString()
        {
            return "( stack height is " + h + " )";
        }
    }

    private class ConditionTreeNode_CanRecruit extends ConditionTreeNode_Leaf
    {
        String name;
        
        public ConditionTreeNode_CanRecruit(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.canRecruit(name);
            }
            return false;
        }

        public String toString()
        {
            return "( stack can recruit " + name + " )";
        }
    }

    private class ConditionTreeNode_LabelIs extends ConditionTreeNode_Leaf
    {
        String name;
        
        public ConditionTreeNode_LabelIs(String name)
        {
            super();
            this.name = name;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return oracle.hexLabel().equals(name);
            }
            return false;
        }

        public String toString()
        {
            return "( stack is in hex " + name + " )";
        }
    }

    private class ConditionTreeNode_AllAttackerSmallerThan extends ConditionTreeNode_Leaf
    {
        int h;
        
        public ConditionTreeNode_AllAttackerSmallerThan(int h)
        {
            super();
            this.h = h;
        }
        
        public boolean isTrue()
        {
            if (oracle != null)
            {
                return (oracle.biggestAttackerHeight() <= h);
            }
            return true;
        }
        
        public String toString()
        {
            return "( no attacker is bigger than size " + h + " )";
        }
    }

    private class ConditionTreeNode_Random extends ConditionTreeNode_Leaf
    {
        double p;

        public ConditionTreeNode_Random(double p)
        {
            if (p > 1.0)
                this.p = 1.0;
            else
                if (p < 0.0)
                    this.p = 0.0;
                else
                    this.p = p;
        }

        public boolean isTrue()
        {
            return (rnd.nextDouble() < p);
        }

        public String toString()
        {
            return "( " + (100 * p) + " % )";
        }
    }
    
    private abstract class ConditionTreeNode_BinaryOp extends ConditionTreeNode
    {
        ConditionTreeNode ctn1;
        ConditionTreeNode ctn2;

        public ConditionTreeNode_BinaryOp(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            this.ctn1 = ctn1;
            this.ctn2 = ctn2;
        }
    }

    private class ConditionTreeNode_BinaryAnd extends ConditionTreeNode_BinaryOp
    {
        ConditionTreeNode_BinaryAnd(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            super(ctn1,ctn2);
        }

        public boolean isTrue()
        {
            return (ctn1.isTrue() && ctn2.isTrue());
        }

        public String toString()
        {
            return "( " + ctn1 + " and " + ctn2 + " )";
        }
    }

    private class ConditionTreeNode_BinaryOr extends ConditionTreeNode_BinaryOp
    {
        ConditionTreeNode_BinaryOr(ConditionTreeNode ctn1, ConditionTreeNode ctn2)
        {
            super(ctn1,ctn2);
        }
        
        public boolean isTrue()
        {
            return (ctn1.isTrue() || ctn2.isTrue());
        }

        public String toString()
        {
            return "( " + ctn1 + " or " + ctn2 + " )";
        }
    }

    private abstract class ConditionTreeNode_UnaryOp extends ConditionTreeNode
    {
        ConditionTreeNode ctn1;

        public ConditionTreeNode_UnaryOp(ConditionTreeNode ctn1)
        {
            this.ctn1 = ctn1;
        }
    }

    private class ConditionTreeNode_UnaryNot extends ConditionTreeNode_UnaryOp
    {
        public ConditionTreeNode_UnaryNot(ConditionTreeNode ctn1)
        {
            super(ctn1);
        }

        public boolean isTrue()
        {
            return (!(ctn1.isTrue()));
        }

        public String toString()
        {
            return "( not " + ctn1 + " )";
        }
    }
    
    public synchronized String getRecruitHint(
        char terrain,
        LegionInfo legion,
        List recruits,
        HintOracleInterface oracle,
        String[] section)
    {
        String hint = null;
        
        Character index = new Character(terrain);

        for (int i = 0; i < section.length; i++)
        {
            HashMap sectionTerrainToRecruitHintList =
                (HashMap)terrainToRecruitHintList.get(section[i]);
            if (sectionTerrainToRecruitHintList != null)
            {
                List temp = (List)sectionTerrainToRecruitHintList.get(index);
                
                if (temp == null)
                { // no hint for this terrain
                    //Log.debug("HINT: none found for terrain type " + terrain);
                }
                else
                {
                    
                    Iterator hintIt = temp.iterator();
                    while (hintIt.hasNext() && (hint == null))
                    {
                        recruitHintData th = (recruitHintData)hintIt.next();
                        //Log.debug("HINT: checking " + th);
                        synchronized (th)
                        {
                            th.setOracle(oracle);
                            
                            // first, try with all the creatures in the Legion
                            Iterator legionIt = legion.getContents().iterator();
                            while (legionIt.hasNext() && (hint == null))
                            { // this will try creatures as many times as they exist. yuck !
                                String creature = (String)legionIt.next();
                                int num = legion.numCreature(creature);
                                /* Log.debug("HINT: trying to match [1] " + terrain +
                                   " / " + creature +
                                   " / " + num); */
                                if (th.match(terrain, creature, num))
                                {
                                    hint = th.getRecruitee();
                                }
                            }
                            // second, try with all recruitable creature (so that
                            // hint with (number == 0) are tried)
                            Iterator recruitsIt = recruits.iterator();
                            while (recruitsIt.hasNext() && (hint == null))
                            { // this will try creatures as many times as they exist. yuck !
                                String creature = ((Creature)recruitsIt.next()).getName();
                                int num = legion.numCreature(creature);
                                /* Log.debug("HINT: trying to match [2] " + terrain +
                                   " / " + creature +
                                   " / " + num); */
                                if (th.match(terrain, creature, num))
                                {
                                    hint = th.getRecruitee();
                                }
                            }

                            // remove the Oracle, just in case
                            th.setOracle(null);
                        }
                    }
                }
            }
        }
        return hint;
    }

    public synchronized List getInitialSplitHint(String label,
                                                 String[] section)
    {
        List legion = null;

        for (int i = 0; i < section.length; i++)
        {
            HashMap sectionLabelToInitialSplitList = 
                (HashMap)labelToInitialSplitList.get(section[i]);
            if (sectionLabelToInitialSplitList != null)
            {
                List allHints = (List)sectionLabelToInitialSplitList.get(label);

                if (allHints != null)
                {
                    Iterator it = allHints.iterator();
                    boolean done = false;
                
                    while (it.hasNext() && !done)
                    {
                        initialSplitHintData ishd = (initialSplitHintData)it.next();
                    
                        if (rnd.nextDouble() < ishd.getProbability())
                        {
                            List legions = ishd.getLegions();
                        
                            legion = (List)legions.get(rnd.nextInt(legions.size()));
                        
                            done = true;
                        }
                    }
                }
            }
        }
        return legion;
    }

    public int getHintedRecruitmentValueOffset(String name,
                                               String[] section)
    {
        for (int i = 0; i < section.length; i++)
        {
            HashMap sectionNameToRecruitmentValueOffset =
                (HashMap)nameToRecruitmentValueOffset.get(section[i]);
            if (sectionNameToRecruitmentValueOffset != null)
            {
                Integer offset = (Integer)sectionNameToRecruitmentValueOffset.get(name);
                if (offset != null)
                {
                    return offset.intValue();
                }
            }
        }
        return 0;
    }
}

PARSER_END(AIHintLoader)

SKIP :
{
    " "
  | "\r"
  | "\t"
  | "\n"
}

TOKEN :
{
        < COMMENT : "#"(<NOTNEWLINE>)*"\r" | "#"(<NOTNEWLINE>)*"\n" >
|       < #NOTNEWLINE : ~["\n","\r"] >
}

String h_comment() :
{}
{
    <COMMENT>
    {
        return(new String(token.image));
    }
}

TOKEN :
{
    < RECRUIT : "RECRUIT" >
|   < CANREACH : "CANREACH" >
|   < HASCREATURE : "HASCREATURE" >
|   < HEIGHTIS : "HEIGHTIS" >
|   < CANRECRUIT : "CANRECRUIT" >
|   < LABELIS : "LABELIS" >
|   < AVAILABLE : "AVAILABLE" >
|   < ALLATTACKERSMALLERTHAN : "ALLATTACKERSMALLERTHAN" >
|   < OTHERFRIENDLYSTACKHASCREATURE : "OTHERFRIENDLYSTACKHASCREATURE" >
|   < RANDOM : "RANDOM" >
|   < OR : "OR" >
|   < AND : "AND" >
|   < NOT: "NOT" >
|   < OPENPAR : "(" >
|   < CLOSEPAR : ")" >
}

TOKEN :
{
    < INITIALSPLIT: "INITIALSPLIT" >
}

TOKEN :
{
    < RECRUITVALUE: "RECRUITVALUE" >
}

TOKEN :
{
    < SECTIONNAME: (["a"-"z","A"-"Z","0"-"9","_"])+ "AI:" >
}

TOKEN :
{
    < NUMBER : ("-")?(<DIGIT>)+ >
|   < FPNUMBER : (<DIGIT>)+<DOT>(<DIGIT>)* >
|   < #DIGIT : ["0" - "9"] >
|   < #DOT : "." >
}

TOKEN:
{
    < TERRAINLIST : (<TERCAR><COMMA>)*<TERCAR> >
|   < #TERCAR : ["a"-"z","A"-"Z"] >
|   < #COMMA : "," >
}

TOKEN :
{
    < CHAINE : (<CAR>)+ >
|   < QUOTEDCHAINE : "\"" (<QUOTEDCAR>)+ "\"" >
|   < #CAR : ["a"-"z","A"-"Z"] > 
|   < #QUOTEDCAR : ["a"-"z","A"-"Z","0"-"9"," ","_"] >
}

char h_char() :
{}
{
    <TERRAINLIST>
    { return (token.image.charAt(0)); }
}

String h_chaine() :
{}
{
    <CHAINE>
    {
        return(new String(token.image));
    }
|   <QUOTEDCHAINE>
    {
        String tok = new String(token.image);
        String cha = tok.substring(1, tok.length() - 1);
        return(cha);
    }
}

int h_number() :
{}
{
    <NUMBER>
    {
        return(Integer.parseInt(token.image));
    }
}

double h_fpnumber() :
{}
{
    <FPNUMBER>
    { return(Double.parseDouble(token.image)); }
}

/* initial split */

initialSplitHintData h_initialsplit_hint() :
{
    String name;
    double p;
    List inter = new ArrayList();
    initialSplitHintData ishd = new initialSplitHintData();
}
{
    (p = h_fpnumber()) ( <OPENPAR> ( (name = h_chaine())
{ inter.add(name); } )+ <CLOSEPAR> { ishd.addLegion(inter); inter = new ArrayList(); } )+
        {
            ishd.setProbability(p);
            return ishd;
        }
}


/* recruiting */

char h_recruit_reachterrain() :
{
    char tc;
}
{
    <CANREACH> (tc = h_char())
        {
            return tc;
        }
}

double h_recruit_random() :
{
    double p;
}
{
    <RANDOM> (p = h_fpnumber())
    {
        return p;
    }
}

void h_recruit_ornode() :
{}
{
    h_recruit_andnode() ( <OR> h_recruit_andnode()
    {
        ConditionTreeNode ctn1 = (ConditionTreeNode)argStack.pop();
        ConditionTreeNode ctn2 = (ConditionTreeNode)argStack.pop();
        argStack.push(new ConditionTreeNode_BinaryOr(ctn1,ctn2));
    } ) *
}

void h_recruit_andnode() :
{}
{
    h_recruit_unarynode() ( <AND> h_recruit_unarynode()
    {
        ConditionTreeNode ctn1 = (ConditionTreeNode)argStack.pop();
        ConditionTreeNode ctn2 = (ConditionTreeNode)argStack.pop();
        argStack.push(new ConditionTreeNode_BinaryAnd(ctn1,ctn2));
    } ) *
}

void h_recruit_unarynode() :
{}
{
    <NOT> h_recruit_leaf()
    {
        ConditionTreeNode ctn1 = (ConditionTreeNode)argStack.pop();
        argStack.push(new ConditionTreeNode_UnaryNot(ctn1));
    }
|   h_recruit_leaf()
}

void h_recruit_leaf() :
{
    char tc;
    int n;
    String name;
    double p;
    java.util.List allNames = new ArrayList();
}
{
    (tc = h_recruit_reachterrain())
    {
        argStack.push(new ConditionTreeNode_CanReach(tc));
    }
|   <HASCREATURE> (name = h_chaine())
    {
        argStack.push(new ConditionTreeNode_HasCreature(name));
    }
|   (p = h_recruit_random())
    {
        argStack.push(new ConditionTreeNode_Random(p));
    }
|   (n = h_number()) (name = h_chaine()) <AVAILABLE>
    {
        argStack.push(new ConditionTreeNode_CreatureAvailable(n,name));
    }
|   <CANRECRUIT> (name = h_chaine())
    {
        argStack.push(new ConditionTreeNode_CanRecruit(name));
    }
|   <HEIGHTIS> (n = h_number())
    {
        argStack.push(new ConditionTreeNode_HeightIs(n));
    }
|   <LABELIS> (name = h_chaine())
    {
        argStack.push(new ConditionTreeNode_LabelIs(name));
    }
|   <ALLATTACKERSMALLERTHAN> (n = h_number())
    {
        argStack.push(new ConditionTreeNode_AllAttackerSmallerThan(n));
    }
|   <OTHERFRIENDLYSTACKHASCREATURE> (name = h_chaine() { allNames.add(name); } )+
    {
        argStack.push(new ConditionTreeNode_OtherFriendlyStackHasCreature(allNames));
    }
|   "(" h_recruit_ornode() ")"
}

recruitHintData h_recruit_hint() :
{
    char tc;
    String recruiter;
    int number;
    String recruitee;
}
{
    <RECRUIT> (tc = h_char()) (recruiter = h_chaine()) (number = h_number()) (recruitee = h_chaine())
        {
            return new recruitHintData(tc,recruiter,number,recruitee);
        }
}

int oneHint() :
{
    recruitHintData recruitHint;
    String s;
    String label;
    String name;
    int offset;
    initialSplitHintData ishd;
}
{
    (recruitHint = h_recruit_hint()) (h_recruit_ornode())?
    {
        Character index = new Character(recruitHint.getTerrain());

        ConditionTreeNode ctn = null;

        if (!argStack.empty())
        {
            ctn = (ConditionTreeNode)argStack.pop();
        }

        HashMap sectionTerrainToRecruitHintList =
                (HashMap)terrainToRecruitHintList.get(currentSection);
        List temp = (List)sectionTerrainToRecruitHintList.get(index);

        if (temp == null)
        {
            temp = new ArrayList();
            sectionTerrainToRecruitHintList.put(index, temp);
        }
        
        if (ctn != null)
        {
            recruitHint.setConditionTreeNode(ctn);
        }

        temp.add(recruitHint);

        /* Log.debug("HINT: Recruit hint in " + recruitHint.getTerrain() +
                  " with " + recruitHint.getNumber() + " " + 
                  recruitHint.getRecruiter() + " get a " + 
                  recruitHint.getRecruitee() +
                  (ctn == null ? "" : " if " + ctn)); */
        return(1);
    }
|   <INITIALSPLIT> (label = h_chaine()) (ishd = h_initialsplit_hint())
    {
        HashMap sectionLabelToInitialSplitList = 
                (HashMap)labelToInitialSplitList.get(currentSection);
        List isl = (List)sectionLabelToInitialSplitList.get(label);

        if (isl == null)
        {
            isl = new ArrayList();
            sectionLabelToInitialSplitList.put(label, isl);
        }
        //Log.debug("HINT: Initial Split hint for hex " + label + " is " + ishd);
        
        isl.add(ishd);
        
        return(1);
    }
|   <RECRUITVALUE> (name = h_chaine()) (offset = h_number())
    {
        HashMap sectionNameToRecruitmentValueOffset =
                (HashMap)nameToRecruitmentValueOffset.get(currentSection);
        sectionNameToRecruitmentValueOffset.put(name, new Integer(offset));

        return 1;
    }
|   <SECTIONNAME>
    {
        Log.debug("HINT: Entering section " + token.image);
        currentSection = token.image;
        if (terrainToRecruitHintList.get(currentSection) == null)
        {
            terrainToRecruitHintList.put(currentSection, new HashMap());
        }
        if (labelToInitialSplitList.get(currentSection) == null)
        {
            labelToInitialSplitList.put(currentSection, new HashMap());
        }
        if (nameToRecruitmentValueOffset.get(currentSection) == null)
        {
            nameToRecruitmentValueOffset.put(currentSection, new HashMap());
        }
        return(0);
    }
|   (s = h_comment())
    {
        return(0);
    }
|   <EOF>
    {
        return(-1);
    }
}
