options
{
  IGNORE_CASE = false;
  STATIC = false;
}

PARSER_BEGIN(StrategicMapLoader)
package net.sf.colossus.parser;


import java.util.*;

import net.sf.colossus.util.Log;
import net.sf.colossus.server.Constants;
import net.sf.colossus.client.MasterHex;
import net.sf.colossus.client.GUIMasterHex;
import net.sf.colossus.server.Game;

/**
 * StrategicMapLoader load the description of the MasterBoard.
 * @author Romain Dolbeau
 * @version $Id$
 * @see net.sf.colossus.client.MasterHex
 */
public class StrategicMapLoader
{
    /**
     * Map the textual description of a transition to the constant representing the same transition.
     */
    static Hashtable stringToWay;
    
    /**
     * Initialize the loader, in particular the text-to-constant mapping.
     * @see #stringToWay
     */
    public void StrategicMapLoaderInit()
    {
        stringToWay = new Hashtable(4);
        stringToWay.put("ARROW", new Integer(Constants.ARROW));
        stringToWay.put("ARROWS",  new Integer(Constants.ARROWS));
        stringToWay.put("ARCH",  new Integer(Constants.ARCH));
        stringToWay.put("BLOCK", new Integer(Constants.BLOCK));
    }
}

PARSER_END(StrategicMapLoader)

SKIP :
{
        " "
  |     "\r"
  |     "\t"
}

TOKEN :
{
        < COMMENT : "#"(<NOTNEWLINE>)*"\r" | "#"(<NOTNEWLINE>)*"\n" >
|       < #NOTNEWLINE : ~["\n","\r"] >
}

String c_comment() :
{}
{
    <COMMENT>
    {
        return(new String(token.image));
    }
}

TOKEN :
{
        < EOL: "\n" >
}

TOKEN :
{
        < NUMBER : (<DIGIT>)+ >
|       < #DIGIT: ["0" - "9"] >
}

TOKEN :
{
        < TERRAIN : ["a"-"z","A"-"Z"] >
}

TOKEN :
{
        < WAY : "ARROW"|"ARROWS"|"ARCH"|"BLOCK" >
}

char c_terrain() :
{}
{
    <TERRAIN>
    {
        return(token.image.charAt(0));
    }
}

int c_number() :
{}
{
    <NUMBER>
    {
        return(Integer.parseInt(token.image));
    }
}

int c_way() :
{}
{
    <WAY>
    {
        return(((Integer)stringToWay.get(token.image)).intValue());
    }
}

/**
 * @param h The MasterHex array in which the case will be added.
 * @return Status of the parser ; negative at the end of file, positive on success, null on blank line.
 * @see net.sf.colossus.client.MasterHex
 */
int oneCase(MasterHex [][] h, java.util.List list, boolean show[][], boolean isGUI) :
{
    String s;
    char ter;
    int p;
    int s1;
    int s2;
    int s3;
    int ts1;
    int ts2;
    int ts3;
    int posX;
    int posY;
    int nPosX;
    int nPosY;
}
{
    (p = c_number()) (ter = c_terrain()) (s1 = c_number()) (ts1 = c_way()) (s2 = c_number()) (ts2 = c_way()) (s3 = c_number()) (ts3 = c_way()) (posX = c_number()) (posY = c_number())
    {
        //nPosX = posX-1;
        //nPosY = (posY-1)/2;
        Log.debug("Adding case #" + p + " @(" + posX + "," + posY +
            "), type " + Game.getTerrainName(ter) + " with exit : " +
            s1 + ", " + s2 + ", " + s3);
        if (isGUI)
            h[posX][posY] = new GUIMasterHex();
        else
            h[posX][posY] = new MasterHex();
        show[posX][posY] = true;
        list.add(h[posX][posY]);

        h[posX][posY].setTerrain(ter);
        h[posX][posY].setLabel(p);
        h[posX][posY].setXCoord(posX);
        h[posX][posY].setYCoord(posY);
        if (s1 > 0) 
        {
            h[posX][posY].setBaseExitType(0, ts1);
        }
        else 
        {
            h[posX][posY].setBaseExitType(0, Constants.NONE);
        }
        h[posX][posY].setBaseExitLabel(0, s1);
        if (s2 > 0) 
        {
            h[posX][posY].setBaseExitType(1, ts2);
        } 
        else 
        {
            h[posX][posY].setBaseExitType(1, Constants.NONE);
        }
        h[posX][posY].setBaseExitLabel(1, s2);
        if (s3 > 0) 
        {
            h[posX][posY].setBaseExitType(2, ts3);
        } 
        else 
        {
            h[posX][posY].setBaseExitType(2, Constants.NONE);
        }
        h[posX][posY].setBaseExitLabel(2, s3);
        return(1);
    }
|   <EOL>
    {
        return(0);
    }
|   (s = c_comment())
    {
        Log.debug("Found comment : " + s);
        return(0);
    }
|   <EOF>
    {
        return(-1);
    }
}

int[] getHexArraySize() :
{
    int[] size = new int[2];
}
{
    (size[0] = c_number()) (size[1] = c_number()) <EOL>
    {
        if ((size[0] < Constants.MIN_HORIZ_SIZE) ||
            (size[0] > Constants.MAX_HORIZ_SIZE) ||
            (size[1] < Constants.MIN_VERT_SIZE) ||
            (size[1] > Constants.MAX_VERT_SIZE))
        {
            throw new ParseException(
                "MasterBoard size out of range : " +
                size[0] + ", " + size[1]);
        }
        return(size);
    }
}