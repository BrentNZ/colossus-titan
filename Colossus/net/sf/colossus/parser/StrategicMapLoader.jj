options
{
  IGNORE_CASE = false;
  STATIC = false;
}

PARSER_BEGIN(StrategicMapLoader)
package net.sf.colossus.parser;


import java.util.*;

import net.sf.colossus.util.Log;
import net.sf.colossus.server.Constants;
import net.sf.colossus.client.MasterHex;

/**
 * StrategicMapLoader load the description of the MasterBoard.
 * @author Romain Dolbeau
 * @author David Ripton
 * @version $Id$
 * @see net.sf.colossus.client.MasterHex
 */
public class StrategicMapLoader
{
    /**
     * Map the textual description of a transition to the constant representing the same transition.
     */
    static Hashtable stringToWay;
    
    /**
     * Initialize the loader, in particular the text-to-constant mapping.
     * @see #stringToWay
     */
    static
    {
        stringToWay = new Hashtable(4);
        stringToWay.put("ARROW", new Integer(Constants.ARROW));
        stringToWay.put("ARROWS",  new Integer(Constants.ARROWS));
        stringToWay.put("ARCH",  new Integer(Constants.ARCH));
        stringToWay.put("BLOCK", new Integer(Constants.BLOCK));
    }
}

PARSER_END(StrategicMapLoader)

SKIP :
{
        " "
  |     "\r"
  |     "\t"
}

TOKEN :
{
        < COMMENT : "#"(<NOTNEWLINE>)*"\r" | "#"(<NOTNEWLINE>)*"\n" >
|       < #NOTNEWLINE : ~["\n","\r"] >
}

String c_comment() :
{}
{
    <COMMENT>
    {
        return(new String(token.image));
    }
}

TOKEN :
{
        < EOL: "\n" >
}

TOKEN :
{
        < NUMBER : (<DIGIT>)+ >
|       < #DIGIT: ["0" - "9"] >
}

TOKEN :
{
        < WAY : "ARROW"|"ARROWS"|"ARCH"|"BLOCK" >
}

TOKEN :
{
    < CHAINE : <CAR> (<NUMCAR>)* >
|   < QUOTEDCHAINE : "\"" (<QUOTEDCAR>)+ "\"" >
|   < #CAR : ["a"-"z","A"-"Z",".","_"] >
|   < #NUMCAR : <CAR>|["0"-"9"] >
|   < #QUOTEDCAR : <NUMCAR>|" " >
}

String c_chaine() :
{}
{
    <CHAINE>
    {
        return(new String(token.image));
    }
|   <QUOTEDCHAINE>
    {
        String tok = new String(token.image);
        String cha = tok.substring(1, tok.length() - 1);
        return(cha);
    }
}

int c_number() :
{}
{
    <NUMBER>
    {
        return(Integer.parseInt(token.image));
    }
}

int c_way() :
{}
{
    <WAY>
    {
        return(((Integer)stringToWay.get(token.image)).intValue());
    }
}

/**
 * @param h The MasterHex array in which the case will be added.
 * @return Status of the parser ; negative at the end of file, positive on success, null on blank line.
 * @see net.sf.colossus.client.MasterHex
 */
int oneCase(MasterHex [][] array, boolean [][] show) :
{
    String s;
    String ter;
    int p;
    int s1;
    int s2;
    int s3;
    int ts1;
    int ts2;
    int ts3;
    int posX;
    int posY;
    int nPosX;
    int nPosY;
}
{
    (p = c_number()) (ter = c_chaine()) (s1 = c_number()) (ts1 = c_way()) (s2 = c_number()) (ts2 = c_way()) (s3 = c_number()) (ts3 = c_way()) (posX = c_number()) (posY = c_number())
    {
        array[posX][posY] = new MasterHex();
        show[posX][posY] = true;

        array[posX][posY].setTerrain(ter);
        array[posX][posY].setLabel(p);
        array[posX][posY].setXCoord(posX);
        array[posX][posY].setYCoord(posY);
        if (s1 > 0) 
        {
            array[posX][posY].setBaseExitType(0, ts1);
        }
        else 
        {
            array[posX][posY].setBaseExitType(0, Constants.NONE);
        }
        array[posX][posY].setBaseExitLabel(0, s1);
        if (s2 > 0) 
        {
            array[posX][posY].setBaseExitType(1, ts2);
        } 
        else 
        {
            array[posX][posY].setBaseExitType(1, Constants.NONE);
        }
        array[posX][posY].setBaseExitLabel(1, s2);
        if (s3 > 0) 
        {
            array[posX][posY].setBaseExitType(2, ts3);
        } 
        else 
        {
            array[posX][posY].setBaseExitType(2, Constants.NONE);
        }
        array[posX][posY].setBaseExitLabel(2, s3);
        return(1);
    }
|   <EOL>
    {
        return(0);
    }
|   (s = c_comment())
    {
        return(0);
    }
|   <EOF>
    {
        return(-1);
    }
}

int[] getHexArraySize() :
{
    int[] size = new int[2];
}
{
    (size[0] = c_number()) (size[1] = c_number()) <EOL>
    {
        if ((size[0] < Constants.MIN_HORIZ_SIZE) ||
            (size[0] > Constants.MAX_HORIZ_SIZE) ||
            (size[1] < Constants.MIN_VERT_SIZE) ||
            (size[1] > Constants.MAX_VERT_SIZE))
        {
            throw new ParseException(
                "MasterBoard size out of range : " +
                size[0] + ", " + size[1]);
        }
        return(size);
    }
}
