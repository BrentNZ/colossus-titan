options
{
  IGNORE_CASE = false;
  STATIC = false;
}

PARSER_BEGIN(TerrainRecruitLoader)
package net.sf.colossus.parser;


import java.util.*;

import net.sf.colossus.util.Log;
import net.sf.colossus.util.HTMLColor;
import net.sf.colossus.server.Creature;

/**
 * TerrainRecruitLoader load the terrains and recruits descriptions.
 * @author Romain Dolbeau
 * @version $Id$
 * @see net.sf.colossus.server.Creature
 */
public class TerrainRecruitLoader
{
    /**
     * Map a character (representing a terrain) to a list of recruits.
     */
    Hashtable carToRecruits = new Hashtable();
    /**
     * Map a character (representing a terrain) to a terrain name.
     */
    Hashtable carToName = new Hashtable();
    /**
     * Map a character (representing a terrain) to a terrain color.
     */
    Hashtable carToColor = new Hashtable();
    /**
     * Map a character (representing a terrain) to a boolean, telling if a Creature can recruit belowe its rank or not.
     */
    Hashtable carToBelow = new Hashtable();
    /**
     * All the character that are valid terrains.
     */
    private char[] terrains = null;

    /**
     * Return an array of all the char representing a valid terrain.
     * @return An array of char, each representing a valid terrain.
     */
    public char[] getTerrains()
    {
        return (char [])terrains.clone();
    }

    /**
     * Used internally to associate a creature name and the number of creatures needed to recruit it.
     * @author Romain Dolbeau
     * @version $Id$
     */
    class recruitNumber
    {
        /**
         * Name of the creature
         */
        public String name;
        /**
         * Number of creatures needed to recruit it, depend on the terrain.
         */
        public int number;
        /**
         * @param n Name of the creature
         * @param i Number of creatures needed to recruit it in the terrain considered.
         */
        public recruitNumber(String n, int i)
        {
            name = n; number = i;
        }
        /**
         * Textual representation of the data.
         * @return Textual representation of the data as a String.
         */
        public String toString()
        {
            return("(" + number + "," + name +")");
        }
    }
    /**
     * Give an array of the starting creatures, those available in the first turn and in the tower.
     * @return an array of Creature representing the starting creatures.
     * @see net.sf.colossus.server.Creature
     */
    public Creature[] getStartingCreatures()
    {
        Creature[] bc = new Creature[3];
        java.util.List to = getPossibleRecruits('T');
        bc[0] = (Creature)to.get(0);
        bc[1] = (Creature)to.get(1);
        bc[2] = (Creature)to.get(2);
        return(bc);
    }
    /**
     * Give the name of the terrain.
     * @param tc Character representing a terrain.
     * @return The name of the terrain as a String.
     */
    public String getTerrainName(char tc)
    {
        return((String)carToName.get(new Character(tc)));
    }
    /**
     * Give the color of the terrain.
     * @param tc Character representing a terrain.
     * @return The color of the terrain as Color.
     */
    public java.awt.Color getTerrainColor(char tc)
    {
        return((java.awt.Color)carToColor.get(new Character(tc)));
    }
    /**
     * Give a modifiable list of the possible recruits in a terrain.
     * @param terrain Character representing a terrain.
     * @return List of Creatures that can be recruited in the terrain.
     * @see net.sf.colossus.server.Creature
     */
    public java.util.List getPossibleRecruits(char terrain)
    {
        ArrayList al = (ArrayList)carToRecruits.get(new Character(terrain));
        ArrayList re = new ArrayList();
        Iterator it = al.iterator();
        while (it.hasNext())
        {
            recruitNumber tr = (recruitNumber)it.next();
            if ((tr.number > 0) && !(tr.name.equals("Anything"))
                                && !(tr.name.equals("Lord")))
            {
                re.add(Creature.getCreatureByName(tr.name));
            }
        }
        return(re);
    }
    /**
     * Give a modifiable list of the possible recruiters in a terrain.
     * @param terrain Character representing a terrain.
     * @return List of Creatures that can recruit in the terrain.
     * @see net.sf.colossus.server.Creature
     */
    public java.util.List getPossibleRecruiters(char terrain)
    {
        ArrayList al = (ArrayList)carToRecruits.get(new Character(terrain));
        ArrayList re = new ArrayList();
        Iterator it = al.iterator();
        while (it.hasNext())
        {
            recruitNumber tr = (recruitNumber)it.next();
            if (!(tr.name.equals("Anything")) &&
                !(tr.name.equals("Lord")))
            {
                re.add(Creature.getCreatureByName(tr.name));
            }
            else
            {
                if (tr.name.equals("Anything"))
                { // anyone can recruit here...
                    java.util.List creatures = Creature.getCreatures();
                    return(new ArrayList(creatures));
                }
                if (tr.name.equals("Lord"))
                {
                    java.util.List potential = Creature.getCreatures();
                    ListIterator lit = potential.listIterator();
                    while (lit.hasNext())
                    {
                        Creature creature = (Creature)lit.next();
                        if (creature.isLord())
                        {
                            re.add(creature);
                        }
                    }
                }

            }
        }
        return(re);
    }
    /**
     * Give a modifiable list of all the possible recruiters in a terrain, including the 'Fake' ones.
     * @param terrain Character representing a terrain.
     * @return List of Creatures that can recruit in the terrain, including the 'Fake' ones.
     * @see net.sf.colossus.server.Creature
     */
    private java.util.List getPossibleFakeRecruiters(char terrain)
    {
        ArrayList al = (ArrayList)carToRecruits.get(new Character(terrain));
        ArrayList re = new ArrayList();
        Iterator it = al.iterator();
        while (it.hasNext())
        {
            recruitNumber tr = (recruitNumber)it.next();
            if (!(tr.name.equals("Anything")) &&
                !(tr.name.equals("Lord")))
            {
                re.add(Creature.getCreatureByName(tr.name));
            }
            else
            {
                re.add(Creature.unknown);
            }
        }
        return re;
    }

    /**
     * Give the number of a given recruiters needed to recruit a given Creature.
     * @param recruiter The Creature that wish to recruit.
     * @param recruit The Creature that is to be recruited.
     * @param terrain Character representing a terrain, in which the recruiting occurs.
     * @return Number of recruiter needed.
     * @see net.sf.colossus.server.Creature
     */
    public int numberOfRecruiterNeeded(Creature recruiter, Creature recruit, char terrain)
    {
        if (terrain != 'T') /* handle Tower with care */
        {
            ArrayList al = (ArrayList)carToRecruits.get(new Character(terrain));
            java.util.List pc = getPossibleRecruits(terrain);
            java.util.List pr = getPossibleFakeRecruiters(terrain);
            boolean recruitBelow = ((Boolean)carToBelow.get(new Character(terrain))).booleanValue();

            int iReer = pc.indexOf(recruiter);
            int iRe = pc.indexOf(recruit);
            int iReerFake = pr.indexOf(recruiter);
            int iReFake = pr.indexOf(recruit);
            if (iRe == -1)
            { // can't be recruited here
                return 99;
            }
            if ((iReer >= iRe) && recruitBelow)
            { // only one to recruit same or below if possible
                return 1;
            }
            if ((iReer != -1) && ((iReer+1) < iRe))
            { // can't recruit 2 or more above
                return 99;
            }
            if (iReer != -1)
            { // regular recruitments
                return (((recruitNumber)al.get(iReFake)).number);
            }
            if (iReFake == 0)
            { // first in stack, itself only (taken care of above)
                return 99;
            }

            // OK, now iReer == -1, but it still can recruit
            // it's something that can recruit, but cannot be recruited

            // find out what's below the recruit in the recruiters stack
            String below = ((recruitNumber)al.get(iReFake - 1)).name;

            // First, "Anything" ; the number is needed no matter what
            // the recruiter is
            if (below.equals("Anything"))
                return (((recruitNumber)al.get(iReFake)).number);
            // Second, "Lord" ; only one Lord can recruit
            if (below.equals("Lord") && (recruiter.isLord()))
                return 1;
            // Third, "Titan" ; only the Titan can recruit
            if (below.equals("Titan") && (recruiter.isTitan()))
                return 1;
            // not possible to recruit, after all
            return 99;
        }
        /* Tower, special */
        java.util.List to = getPossibleRecruits(terrain); /* this is 'T' */
        if (recruit.getName().equals(((Creature)to.get(0)).getName()) ||
            recruit.getName().equals(((Creature)to.get(1)).getName()) ||
            recruit.getName().equals(((Creature)to.get(2)).getName()))
        { // first three can be recruited by anything
            return 0;
        }
        else if (recruit.getName().equals(((Creature)to.get(4)).getName()))
        {
            if (recruiter.getName().equals("Titan") ||
                recruiter.getName().equals(((Creature)to.get(4)).getName()))
            { // fifth recruited by Titan or itself
                return 1;
            } 
            else
            {
                return 99;
            }
        } 
        else if (recruit.getName().equals(((Creature)to.get(3)).getName()))
        { // fourth recruited by any 3 or itself
            if (recruiter.getName().equals(((Creature)to.get(3)).getName()))
            {
                return 1;
            }
            else 
            {
                return 3;
            }
        } 
        else 
        {
            return 99;
        }
    }
}

PARSER_END(TerrainRecruitLoader)

SKIP :
{
    " "
  | "\r"
  | "\t"
}

TOKEN :
{
        < COMMENT : "#"(<NOTNEWLINE>)*"\r" | "#"(<NOTNEWLINE>)*"\n" >
|       < #NOTNEWLINE : ~["\n","\r"] >
}

String r_comment() :
{}
{
    <COMMENT>
    {
        return(new String(token.image));
    }
}

TOKEN :
{
    < EOL: "\n" >
}

TOKEN :
{
    < NUMBER : (<DIGIT>)+ >
|   < #DIGIT : ["0" - "9"] >
}

TOKEN :
{
    < TERCAR : ["a"-"z","A"-"Z"] >
}

TOKEN :
{
    < BOOL: "true"|"false" >
}

TOKEN :
{
    < CHAINE : (<CAR>)+ >
|   < #CAR : ["a"-"z","A"-"Z"] >
}

boolean r_bool() :
{}
{
    <BOOL>
    { if (token.image.equals("true")) return true; else return false; }
}

char r_char() :
{}
{
    <TERCAR>
    { return (token.image.charAt(0)); }
}

String r_chaine() :
{}
{
    <CHAINE>
    {
        return(new String(token.image));
    }
}

int r_number() :
{}
{
    <NUMBER>
    {
        return(Integer.parseInt(token.image));
    }
}

ArrayList r_allRecruit() :
{
    ArrayList temp;
    int i;
    String n;
}
{
    (i = r_number()) (n = r_chaine()) (temp = r_allRecruit())
    { temp.add(0, new recruitNumber(n, i)); return temp; }
|   /* empty */
    { return new ArrayList(); }

}

/**
 * Load a terrain and the recruit possibility in this terrain.
 * @return Status of the parser ; negative at the end of file, positive on success, null on blank line.
 */
int oneTerrain() :
{
    String t;
    String col;
    char tc;
    ArrayList rl;
    String s;
    boolean rb;
}
{
    (tc = r_char()) (col = r_chaine()) (t = r_chaine())
        (rb = r_bool()) (rl = r_allRecruit())
    {
        carToRecruits.put(new Character(tc), rl);
        carToName.put(new Character (tc), t);
        carToColor.put(new Character (tc), HTMLColor.stringToColor(col));
        carToBelow.put(new Character (tc), new Boolean (rb));
        if (terrains == null)
        {
            terrains = new char[1];
            terrains[0] = tc;
        } 
        else 
        {
            char[] t2 = new char[terrains.length + 1];
            for (int i = 0; i < terrains.length ; i++)
            {
                t2[i] = terrains[i];
            }
            t2[terrains.length] = tc;
            terrains = t2;
        }
        Log.debug("Adding recruits for " + t + " " + rl);
        return(1);
    }
|   <EOL>
    {
        return(0);
    }
|   (s = r_comment())
    {
        Log.debug("Found comment : " + s);
        return(0);
    }
|   <EOF>
    {
        return(-1);
    }
}
