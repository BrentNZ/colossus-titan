package net.sf.colossus.tools;

import java.io.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;

import net.sf.colossus.xmlparser.BattlelandLoader;
import net.sf.colossus.variant.BattleHex;
import net.sf.colossus.client.GUIBattleHex;
import net.sf.colossus.client.GUIHex;
import net.sf.colossus.client.HexMap;
import net.sf.colossus.variant.HazardTerrain;

/**
 * Class BuilderHexMap displays a basic battle map.
 * @version $Id$
 * @author David Ripton
 * @author Romain Dolbeau
 */
public class BuilderHexMap extends HexMap
{
    String filename = null;
    protected boolean isTower = false;
    protected int scale = 2 * 15;
    protected int cx = 6 * scale;
    protected int cy = 2 * scale;

    BuilderHexMap(String f)
    {
        super(null, false);
        filename = f;

        setOpaque(true);
        setBackground(Color.white);
        setupHexes();
    }

    protected void setupHexes()
    {
        setupHexesGUI();
        setupNeighbors(h);
        setupHexesGameState2(getBattleHexArray());
    }

    BattleHex[][] getBattleHexArray()
    {
        BattleHex[][] h2 = new BattleHex[6][6];
        for (int i = 0; i < h.length; i++)
        {
            for (int j = 0; j < h[0].length; j++)
            {
                if (h[i][j] != null)
                {
                    h2[i][j] = h[i][j].getHexModel();
                }
            }

        }
        return h2;
    }

    /** Add terrain, hexsides, elevation, and exits to hexes.
     *  Cliffs are bidirectional; other hexside obstacles are noted
     *  only on the high side, since they only interfere with
     *  uphill movement. */
    private synchronized void setupHexesGameState2(BattleHex[][] lh)
    {
        if (filename != null)
        {
            InputStream terIS = null;

            try
            {
                terIS = new FileInputStream(filename);
            } catch (Exception e)
            {
                System.out.println("Battlelands file loading failed : " + e);
            }
            try
            {
                BattlelandLoader bl = new BattlelandLoader(terIS, lh);
            } catch (Exception e)
            {
                System.out.println("Battlelands file parsing failed : " + e);
            }
        }
    }

    public void paintComponent(Graphics g)
    {
        super.paintComponent(g);
    }

    public Dimension getMinimumSize()
    {
        return getPreferredSize();
    }

    public Dimension getPreferredSize()
    {
        return new Dimension(60 * 15, 55 * 15);
    }

    public String dumpAsString()
    {
        StringBuilder buf = new StringBuilder();
        HazardTerrain terrain;
        char s;
        int e;
        List<GUIBattleHex> localStartList = new ArrayList<GUIBattleHex>();

        buf.append("# Battlelands generated by BattlelandsBuilder\n");
        buf.append(
                "# You can uncomment the line below to give this Battlelands a subtitle\n");
        buf.append("#SUBTITLE <put_your_subtitle_here>\n");

        for (int i = 0; i < 6; i++)
        {
            for (int j = 0; j < 6; j++)
            {
                if (show[i][j])
                {
                    boolean doDumpSides = false;
                    boolean hasSlope = false;
                    boolean hasWall = false;
                    terrain = h[i][j].getHexModel().getTerrain();
                    e = h[i][j].getHexModel().getElevation();

                    if (h[i][j].isSelected())
                    {
                        localStartList.add(h[i][j]);
                    }

                    for (int k = 0; k < 6; k++)
                    {
                        s = h[i][j].getHexModel().getHexside(k);
                        if (s != ' ')
                        {
                            doDumpSides = true;
                        }
                        if (s == 's')
                        {
                            hasSlope = true;
                        }
                        if (s == 'w')
                        {
                            hasWall = true;
                        }
                    }
                    if (doDumpSides ||
                            (!terrain.equals(HazardTerrain.getTerrainByName(
                            "Plains"))) ||
                            (e != 0))
                    {
                        if ((e < 1) && hasSlope)
                        {
                            buf.append(
                                    "# WARNING: slope on less-than-1 elevation Hex\n");
                        }
                        if ((!terrain.equals(HazardTerrain.getTerrainByName(
                                "Tower"))) && hasWall)
                        {
                            buf.append("# WARNING: wall on non-Tower Hex\n");
                        }
                        if ((e < 1) && hasWall)
                        {
                            buf.append(
                                    "# WARNING: wall on less-than-1 elevation Hex\n");
                        }
                        if ((terrain.equals(HazardTerrain.getTerrainByName(
                                "Lake"))) && doDumpSides)
                        {
                            buf.append("# WARNING: non-default sides on Lake\n");
                        }
                        if ((terrain.equals(HazardTerrain.getTerrainByName(
                                "Tree"))) && doDumpSides)
                        {
                            buf.append("# WARNING: non-default sides on Tree\n");
                        }
                        buf.append(i);
                        buf.append(" ");
                        buf.append(j);
                        buf.append(" ");
                        buf.append(h[i][j].getHexModel().getTerrain());
                        buf.append(" ");
                        buf.append(h[i][j].getHexModel().getElevation());
                        if (doDumpSides)
                        {
                            for (int k = 0; k < 6; k++)
                            {
                                if (h[i][j].getHexModel().getHexside(k) != ' ')
                                {
                                    buf.append(" ");
                                    buf.append(k);
                                    buf.append(" ");
                                    buf.append(h[i][j].getHexModel().getHexside(
                                            k));
                                }
                            }
                        }
                        buf.append("\n");
                    }
                }
            }
        }

        if (isTower)
        {
            buf.append("# This is a Tower\nTOWER\n");
        }
        if (!localStartList.isEmpty())
        {
            buf.append("# This terrain has a startlist\nSTARTLIST");
            for (GUIBattleHex lh : localStartList) {
                buf.append(" " + lh.getHexModel().getLabel());
            }
            buf.append("\n");
        }

        return (buf.toString());
    }

    void eraseMap()
    {
        for (GUIBattleHex hex : hexes)
        {
            hex.getHexModel().setTerrain(HazardTerrain.getTerrainByName("Plains"));
            hex.getHexModel().setElevation(0);
            for (int i = 0; i < 6; i++)
            {
                hex.getHexModel().setHexside(i, ' ');
            }
        }
    }
}
